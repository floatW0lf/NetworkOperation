<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="..\NetworkOperation\bin\Debug\net472\NetworkOperation.dll" #>
<#@ assembly name="..\Contract\bin\Debug\net472\Contract.dll" #>
<#@ import namespace="NetworkOperation" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#
    var operations = OperationRuntimeModel.CreateFromAttribute();
    var currentSide = Side.Server; /*or Side.Client */
    var supportAOTCompile = true;
#>

using System;
using System.Threading.Tasks;
using System.Threading;
using NetworkOperation;
using NetworkOperation.Logger;

namespace NetworkOperations.Dispatching
{
    public sealed class PreGeneratedDispatcher<TRequest, TResponse> : BaseDispatcher<TRequest, TResponse>
           where TRequest : IOperationMessage, new() where TResponse : IOperationMessage, new()
    {
        public T4Dispatcher(BaseSerializer serializer, IHandlerFactory factory, OperationRuntimeModel model, IStructuralLogger logger) : base(serializer, factory, model, logger)
        {
        }

        protected override Task<DataWithStateCode> ProcessHandler(Session session, TRequest message, OperationDescription operationDescription, CancellationToken token)
        {
            switch (operationDescription.Code)
            {
<# foreach (OperationDescription op in operations) { if (op == null || !op.Handle.HasFlag(currentSide)) continue; #>
               case <#=op.Code#>: return GenericHandle<<#=op.OperationType.FullName#>, <#=op.ResultType.FullName#>>(session, message, operationDescription, token);
<# } #>
            }
            throw new InvalidOperationException($"Wrong code operation {operationDescription.Code}");
        }
    }
    
<# if (supportAOTCompile) {#>    
    public static AOTSupport
    {
        public static void VirtualGenericMethodsDefinition()
        {
            
        }
    }
<# } #>        
}