<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)\NetworkOperation\bin\Debug\net472\NetworkOperation.dll" #>
<#@ assembly name="$(SolutionDir)\Contract\bin\Debug\net472\Contract.dll" #>
<#@ import namespace="NetworkOperation" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#
    var operations = OperationRuntimeModel.CreateFromAttribute();
    var currentSide = Side.Server;
#>
using System;
using System.Threading.Tasks;
using NetworkOperation;

namespace NetworkOperations.Dispatching
{
    public sealed class T4Dispatcher : BaseDispatcher
    {
        public T4Dispatcher(BaseSerializer serializer, IHandlerFactory factory, OperationRuntimeModel model) : base(serializer, factory, model)
        {
        }

        protected override Task<byte[]> ProcessHandler(Connection context, uint code, byte[] rawData, bool useAsync, CancellationToken token)
        {
            switch (code)
            {
<# foreach (OperationDescription op in operations) { if (op == null || !op.Handle.HasFlag(currentSide)) continue; #>
               case <#=op.Code#>: return GenericHandle<<#=op.OperationType.FullName#>, <#=op.ResultType.FullName#>>(context, rawData, useAsync, token);
<# } #>
            }
            throw new Exception("wrong cmd!");
        }
    }
}